package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"

	"github.com/tagaertner/job-stories/services/stories/generated"
	"github.com/tagaertner/job-stories/services/stories/models"
	"github.com/tagaertner/job-stories/services/stories/services"
)

// CreateStory is the resolver for the createStory field.
func (r *mutationResolver) CreateStory(ctx context.Context, input models.CreateStoryInput) (*generated.JobStory, error) {
	story, err := r.StoryService.CreateStory(
		ctx,
		input,
	)
	if err != nil {
		return nil, err
	}
	return ToGraphQLStory(story), nil
}

// UpdateStory is the resolver for the updateStory field.
func (r *mutationResolver) UpdateStory(ctx context.Context, input models.UpdateStoryInput) (*generated.JobStory, error) {
	story, err := r.StoryService.UpdateStory(
		ctx,
		input.ID,
		input,
	)
	if err != nil {
		return nil, err
	}
	return ToGraphQLStory(story), nil
}

// DeleteStory is the resolver for the deleteStory field.
func (r *mutationResolver) DeleteStory(ctx context.Context, input *models.DeleteStoryInput) (bool, error) {
	return r.StoryService.DeleteStory(ctx, input)
}

// Stories is the resolver for the stories field.
func (r *queryResolver) Stories(ctx context.Context, filter *generated.StoryFilter, limit *int, offset *int) ([]*generated.JobStory, error) {
	allStories, err := r.StoryService.GetAllStories(filter, limit, offset)
	if err != nil {
		return nil, err
	}
	return ToGraphQLStoryList(allStories), nil
}

// Story is the resolver for the story field.
func (r *queryResolver) Story(ctx context.Context, id string) (*generated.JobStory, error) {
	story, err := r.StoryService.GetStoryByID(id)
	if err != nil {
		return nil, err
	}
	return ToGraphQLStory(story), nil
}

// StoriesByUserCursor is the resolver for the storiesByUserCursor field.

func (r *queryResolver) StoriesByUserCursor(ctx context.Context, userID string, after *string, first *int) (*generated.StoryConnection, error) {
	// Set default first
	defaultFirst := 10
	f := defaultFirst
	if first != nil{
		f = *first
	}

	// Validate first
	if f <= 0 || f > 100 {
		return nil, fmt.Errorf("first must be between 1- 100")
	}

	// Get stories from service
	stories, hasNextPage, err := r.StoryService.GetStoriesByUserCursor(ctx, userID, after,f)
	if err != nil {
		return nil, err
	}

	// Build edges
	edges := make([]*generated.StoryEdge, len(stories))
	for i, story := range stories {
		edges[i] = &generated.StoryEdge{
			Cursor: services.EncodeCursor(story),
			Node: ToGraphQLStory(story),
		}
	}

	var endCursor *string
	if len(edges) >0 {
		cursor := edges[len(edges)-1].Cursor
		endCursor = &cursor
	}

	// Build connection
	connection := &generated.StoryConnection{
		Edges: edges,
		PageInfo: &generated.PageInfo{
			HasNextPage: hasNextPage,
			EndCursor: endCursor,
		},
		TotalCount: len(edges),
	}
	return connection, nil 
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) StoriesByUser(ctx context.Context, userID string, page *int, pageSize *int) (*generated.PaginatedStories, error) {
	p := 1
	ps := 2
	if page != nil {
		p = *page
	}
	if pageSize != nil{
		ps = *pageSize
	}

	stories, total, err := r.StoryService.GetStoriesByUser(ctx, userID, p, ps)
	if err != nil{
		return nil, err
	}
	return &generated.PaginatedStories{
		Stories: ToGraphQLStoryList(stories),
		TotalCount: total,
		CurrentPage: p,
		HasNextPage: (p *ps) < total,
	}allStories, err := r.StoryService.GetAllStories(filter, limit, offset)
	if err != nil {
		return nil, err
	}
	
	g,
		nil
	}
*/
